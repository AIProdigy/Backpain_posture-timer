<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<link rel="manifest" href="manifest.webmanifest" />
<link rel="apple-touch-icon" href="icon-192.png" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<title>Posture & Sitting Timer</title>
<link rel="stylesheet" href="style.css" />

<!-- MediaPipe libs (cache-busted) -->
<script src="https://unpkg.com/@mediapipe/drawing_utils@0.3.1675466864/drawing_utils.js?v=12"></script>
<script src="https://unpkg.com/@mediapipe/pose@0.5.1675469404/pose.js?v=12"></script>

<style>
  header { position: sticky; top: 0; background:#0f1115; z-index: 10; }
  #status { padding:8px 12px; margin:10px 12px; border-radius:10px; font-size:13px; }
  #status.ok{ background:#12362f; color:#d7fff1; border:1px solid #245c4d; }
  #status.err{ background:#2b1616; color:#ffd7d7; border:1px solid #5c1f1f; }
  .topButtons{ display:flex; gap:8px; padding:0 12px; margin-top:-4px }
  .topButtons .btn{ flex:1; }
  /* show the video; we draw overlays on a canvas stacked above it */
  #preview { position: relative; }
  #video { width: 100%; border-radius: 12px; background: #000; }
  #canvas { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
</style>
</head>
<body>
<header>
  <h1>Posture & Sitting Timer</h1>
  <label class="toggle">
    Sound
    <span class="switch"><input id="soundToggle" type="checkbox" checked><span class="slider"></span></span>
  </label>
</header>

<div id="status" class="ok">v0.4 — JS loaded. Tap <b>Start</b> to request camera.</div>
<div class="topButtons">
  <button id="startBtn" class="btn accent">Start</button>
  <button id="stopBtn" class="btn">Stop</button>
  <button id="resetBtn" class="btn warn">Reset</button>
</div>

<main>
  <div id="preview" class="card">
    <video id="video" playsinline muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <div class="card">
    <div class="kpi">
      <div><div class="label">Base width</div><div id="kBase" class="value">--</div></div>
      <div><div class="label">Lumbar angle</div><div id="kLumbar" class="value">--</div></div>
      <div><div class="label">Shift</div><div id="kShift" class="value">--</div></div>
    </div>
    <div id="timer">00:00</div>
    <div id="suggestion" class="small"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Adaptive Timer</h3>
    <div class="control-grid">
      <label class="small">Base interval (min)</label>
      <input id="baseInterval" type="range" min="10" max="40" step="5" value="20">
    </div>
    <div class="control-grid">
      <label class="small">Extend when good (min)</label>
      <input id="extendBy" type="range" min="0" max="15" step="5" value="10">
    </div>
    <div class="control-grid">
      <label class="small">Alert earlier when poor (min)</label>
      <input id="reduceBy" type="range" min="0" max="10" step="5" value="5">
    </div>
    <hr>
    <div class="control-grid">
      <label class="small">Target base width (cm, est.)</label>
      <input id="targetBase" type="range" min="0" max="30" step="1" value="8">
    </div>
    <div class="control-grid">
      <label class="small">Max lumbar flex (°)</label>
      <input id="maxFlex" type="range" min="5" max="40" step="1" value="20">
    </div>
    <div class="small" style="margin-top:8px">
      Tip: Phone ~1.5–2m away at knee height. Sit ~45° to camera so it sees shoulders/hips/knees/ankles.
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Pain Check-in</h3>
    <div class="row">
      <input id="pain" type="range" min="0" max="10" step="1" value="1" style="flex:1">
      <button id="logPain" class="btn">Log</button>
    </div>
    <div class="small" id="lastLog">No logs yet.</div>
    <div class="small">Data is stored locally on your device.</div>
  </div>

  <div class="card small">
    <b>Micro-resets I’ll suggest:</b>
    <ul>
      <li><b>Narrow base realignment</b> — feet/knees closer, re-stack ribs over pelvis.</li>
      <li><b>Stand + brace</b> — McGill short-stop; hinge, brace, stand tall.</li>
      <li><b>Hook-lying breathing</b> — 2–3 minutes; neutral pelvis.</li>
    </ul>
  </div>
</main>
<footer>v0.4 prototype · On-device processing · For guidance only</footer>

<script>
(function(){
  const $ = id => document.getElementById(id);
  const ui = {
    status: $('status'),
    video: $('video'),
    canvas: $('canvas'),
    kBase: $('kBase'),
    kLumbar: $('kLumbar'),
    kShift: $('kShift'),
    timer: $('timer'),
    suggestion: $('suggestion'),
    baseInterval: $('baseInterval'),
    extendBy: $('extendBy'),
    reduceBy: $('reduceBy'),
    targetBase: $('targetBase'),
    maxFlex: $('maxFlex'),
    soundToggle: $('soundToggle'),
    pain: $('pain'),
    logPain: $('logPain'),
    lastLog: $('lastLog'),
    startBtn: $('startBtn'),
    stopBtn: $('stopBtn'),
    resetBtn: $('resetBtn'),
  };

  const ok = msg => { ui.status.className='ok'; ui.status.innerHTML = msg; }
  const err = msg => { ui.status.className='err'; ui.status.innerHTML = '⚠️ ' + msg; console.error(msg); }

  // Beep
  let ac;
  function beep(){
    if (!ui.soundToggle.checked) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!ac) ac = new Ctx();
    const o = ac.createOscillator(), g = ac.createGain();
    o.type='sine'; o.frequency.value=880;
    g.gain.value=0.001; o.connect(g).connect(ac.destination);
    o.start();
    g.gain.linearRampToValueAtTime(0.08, ac.currentTime+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+0.3);
    o.stop(ac.currentTime+0.35);
  }

  // Pain logs
  const store = {
    get(){ return JSON.parse(localStorage.getItem('pt_logs')||'[]'); },
    add(x){ const a=store.get(); a.push(x); localStorage.setItem('pt_logs', JSON.stringify(a)); }
  }
  function updateLastLog(){
    const a = store.get(); if (!a.length){ ui.lastLog.textContent='No logs yet.'; return; }
    const last = a[a.length-1];
    ui.lastLog.textContent = `Last log: pain ${last.pain}/10 at ${new Date(last.ts).toLocaleString()}`;
  }
  ui.logPain.addEventListener('click', ()=>{ store.add({pain:+ui.pain.value, ts:Date.now()}); updateLastLog(); });

  // Geometry helpers
  const ctx = ui.canvas.getContext('2d');
  const dist = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);
  function angle(a,b,c){
    const ab={x:a.x-b.x,y:a.y-b.y}, cb={x:c.x-b.x,y:c.y-b.y};
    const dot=ab.x*cb.x+ab.y*cb.y, mag=Math.hypot(ab.x,ab.y)*Math.hypot(cb.x,cb.y);
    if (!mag) return 0; let cos=dot/mag; cos=Math.min(1,Math.max(-1,cos)); return Math.acos(cos)*180/Math.PI;
  }
  function estimateBaseWidth(lm){
    const lA=lm[27], rA=lm[28], lK=lm[25], rK=lm[26];
    if(!lA||!rA||!lK||!rK) return null;
    const px=(dist(lA,rA)+dist(lK,rK))/2; const pxToCm=0.8; return px*pxToCm;
  }
  function lumbarAngle(lm){
    const L=lm[11], R=lm[12], LH=lm[23], RH=lm[24], LK=lm[25], RK=lm[26];
    const lv=(L?.visibility||0)+(LH?.visibility||0)+(LK?.visibility||0);
    const rv=(R?.visibility||0)+(RH?.visibility||0)+(RK?.visibility||0);
    let sh,hip,knee; if(lv>=rv){ sh=L; hip=LH; knee=LK; } else { sh=R; hip=RH; knee=RK; }
    if(!sh||!hip||!knee) return null; return Math.round(angle(sh,hip,knee));
  }
  function lateralShift(lm){
    const shx=(lm[11]?.x + lm[12]?.x)/2, hipx=(lm[23]?.x + lm[24]?.x)/2;
    if(!isFinite(shx)||!isFinite(hipx)) return null; return Math.round((hipx-shx)*100);
  }
  function postureScore(m,t){
    let s=100;
    if(m.baseCm!=null){ const dev=Math.max(0,m.baseCm-t.baseCm); s-=Math.min(40,dev*1.2); }
    if(m.lumbarDeg!=null){ const over=Math.max(0,(180-m.lumbarDeg)-t.maxFlexDeg); s-=Math.min(40,over*1.5); }
    if(m.shiftPct!=null){ s-=Math.min(20,Math.abs(m.shiftPct)*1.2); }
    return Math.max(0,Math.min(100,Math.round(s)));
  }
  function chooseSuggestion(m,t){
    if(m.baseCm!=null && m.baseCm>t.baseCm+3) return "Narrow your base: bring feet & knees closer, re-stack ribs over pelvis.";
    if(m.lumbarDeg!=null && (180-m.lumbarDeg)>t.maxFlexDeg+5) return "Stand + brace (McGill short-stop), then re-sit tall.";
    return "Hold steady. Small adjustments only.";
  }

  // Pose pipeline (RAF loop — no MediaPipe Camera helper)
  let pose, running=false, timerStart=null, lastAlert=0, currentIntervalMs=0, rafId=null;

  function setAdaptiveInterval(score){
    const baseMs=+ui.baseInterval.value*60*1000;
    const extendMs=+ui.extendBy.value*60*1000;
    const reduceMs=+ui.reduceBy.value*60*1000;
    if(score>=75) currentIntervalMs = baseMs+extendMs;
    else if(score<=45) currentIntervalMs = Math.max(180000, baseMs-reduceMs);
    else currentIntervalMs = baseMs;
  }
  function tickTimer(score){
    if(!timerStart) return;
    const elapsed=Date.now()-timerStart;
    const m=Math.floor(elapsed/60000), s=Math.floor((elapsed%60000)/1000);
    ui.timer.textContent = String(m).padStart(2,'0')+':'+String(s).padStart(2,'0');
    if(elapsed>=currentIntervalMs && Date.now()-lastAlert>30000){ beep(); lastAlert=Date.now(); timerStart=Date.now(); }
  }

  function drawResults(results){
    const v = ui.video;
    ui.canvas.width = v.videoWidth || v.clientWidth;
    ui.canvas.height = v.videoHeight || v.clientHeight;
    ctx.drawImage(v, 0, 0, ui.canvas.width, ui.canvas.height);

    const lm = results.poseLandmarks;
    if(lm){
      // overlay landmarks
      try{ drawConnectors(ctx, lm, Pose.POSE_CONNECTIONS, {color:'#334155', lineWidth:3}); }catch{}
      try{ drawLandmarks(ctx, [lm[11],lm[12],lm[23],lm[24],lm[25],lm[26],lm[27],lm[28]], {color:'#93c5fd', radius:3}); }catch{}

      const baseCm=estimateBaseWidth(lm);
      const lumbarDeg=lumbarAngle(lm);
      const shiftPct=lateralShift(lm);
      ui.kBase.textContent = baseCm? Math.round(baseCm)+' cm':'--';
      ui.kLumbar.textContent = lumbarDeg? lumbarDeg+'°':'--';
      ui.kShift.textContent = shiftPct!=null? shiftPct+'%':'--';
      const targets={ baseCm:+ui.targetBase.value, maxFlexDeg:+ui.maxFlex.value };
      const score = postureScore({baseCm,lumbarDeg,shiftPct}, targets);
      setAdaptiveInterval(score);
      ui.suggestion.textContent = chooseSuggestion({baseCm,lumbarDeg,shiftPct}, targets);
      tickTimer(score);
    } else {
      ui.suggestion.textContent = "Get shoulders, hips, knees, ankles in frame.";
    }
  }

  async function loop(){
    if (!running) return;
    try{
      await pose.send({ image: ui.video });
      rafId = requestAnimationFrame(loop);
    } catch(e){
      err("Pose loop error: " + e);
      running = false;
    }
  }

  async function start(){
    if(running) return;
    ok("Requesting camera… If no prompt, set Safari permission to Allow.");
    try{
      const rear = { video: { facingMode: { exact: "environment" } }, audio:false };
      const front = { video: { facingMode: "user" }, audio:false };
      let stream;
      try { stream = await navigator.mediaDevices.getUserMedia(rear); }
      catch { stream = await navigator.mediaDevices.getUserMedia(front); }

      ui.video.srcObject = stream;
      ui.video.muted = true; // iOS autoplay requires muted
      await ui.video.play();

      pose = new Pose.Pose({ locateFile: f => `https://unpkg.com/@mediapipe/pose@0.5.1675469404/${f}` });
      pose.setOptions({ modelComplexity:1, smoothLandmarks:true, enableSegmentation:false, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });
      pose.onResults(drawResults);

      running = true; timerStart = Date.now(); lastAlert = 0;
      ok("Camera running. Position yourself ~1.5–2m away at ~45°.");
      loop();
    } catch(e){
      err("Camera failed: " + (e && e.message ? e.message : e));
      err("Fix: aA → Website Settings → Camera → Allow, then reload.");
    }
  }

  function stop(){
    if(!running) return;
    running=false;
    try{
      rafId && cancelAnimationFrame(rafId);
      const s = ui.video.srcObject; if(s) s.getTracks().forEach(t=>t.stop());
      ui.video.srcObject = null;
      ok("Stopped.");
    }catch(e){ err("Stop error: " + e); }
  }

  ui.startBtn.addEventListener('click', start, {passive:true});
  ui.stopBtn.addEventListener('click', stop, {passive:true});
  ui.resetBtn.addEventListener('click', ()=>{ timerStart = Date.now(); beep(); ok("Timer reset."); }, {passive:true});

  updateLastLog();
  console.log("JS boot OK v0.4");
})();
</script>
</body>
</html>
